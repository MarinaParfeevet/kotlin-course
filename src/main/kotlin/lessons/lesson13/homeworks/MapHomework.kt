package ru.stimmax.lessons.lesson13.homeworks

fun main() {

//1.Дан словарь с именем и временем выполнения каждого автоматизированного теста в секундах. Определите среднее время
// выполнения теста.
    val m1 = mapOf("Anna" to 30, "Petr" to 120, "Semen" to 90, "Kate" to 180)
    val average = m1.values.average()

//2.Имеется словарь с метаданными автоматизированных тестов, где ключи — это имена тестовых методов а значения -
// строка с метаданными. Выведите список всех тестовых методов.
    val m2 = mapOf("test1" to "meta1", "test2" to "meta2", "test3" to "meta3", "test4" to "meta4", "test5" to "meta5")
    m2.forEach { println(it.value) }

//3.В изменяемый словарь с данными о прохождении тестов добавьте новый тест и его результат.
    val m3 = mutableMapOf("test1" to "skipped", "test2" to "failed", "test3" to "passed")
    m3["test4"] = "failed"

//4.Посчитайте количество успешных тестов в словаре с результатами (ключ - название, значение - результат из passed,
// failed, skipped).
    val count = m3.count { it.value == "passed" }

//5.Удалите из изменяемого словаря с баг-трекингом запись о баге, который был исправлен (ключ - название, значение -
// статус исправления).
    val m5 = mutableMapOf("bag1" to "fixed", "bag2" to "open", "bag3" to "in progress", "bag4" to "fixed")
    m5.keys.filter { m5[it] == "fixed" }.forEach { m5.remove(it) }
    println(m5)
    m5.entries.removeIf { it.value == "fixed" }
    println(m5)

//6.Для словаря с результатами тестирования веб-страниц (ключ — URL страницы, значение — статус ответа), выведите
// сообщение о странице и статусе её проверки.
    val m6 = mapOf("url1" to 404, "url2" to 200, "url3" to 303)
    m6.forEach { println("${it.key} has status ${it.value}") }

//7.Найдите в словаре с названием и временем ответа сервисов только те, время ответа которых превышает заданный порог.
    val m7 = mapOf("service1" to 1000, "service2" to 200, "service3" to 2400)
    println(m7.filter { it.value > 900 })

//8.В словаре хранятся результаты тестирования API (ключ — endpoint, значение — статус ответа в виде строки). Для
// указанного endpoint найдите статус ответа, если endpoint отсутствует, предположите, что он не был протестирован.
    val m8 = mapOf("endpoin1" to "200", "endpoin2" to "505", "endpoin3" to "404")
    val r = m8.getOrElse("endpoin7") { "not tested" }

//9.Из словаря, содержащего конфигурации тестового окружения (ключ — название параметра конфигурации, значение - сама
// конфигурация), получите значение для "browserType". Ответ не может быть null.
    val m9 = mapOf("code" to "xxx", "style" to "yyy", "browserType" to "Chrome")
    val res = m9.getValue("browserType")

//10.Создайте копию неизменяемого словаря с данными о версиях тестируемого ПО, добавив новую версию.
    val m10 = mapOf("version1" to "1.4.2", "version2" to "1.4.3", "version3" to "1.4.4", "version4" to "1.4.5")
    val copy10 = m10 + ("version5" to "1.4.6")

//11.Используя словарь с настройками тестирования для различных мобильных устройств (ключ — модель устройства,
// значение - строка с настройками), получите настройки для конкретной модели или верните настройки по умолчанию.
    val m11 = mapOf("s24" to "settings1", "s25" to "settings2")
    val r1 = m11.getOrDefault("A75", "default settings")

//12.Проверьте, содержит ли словарь с ошибками тестирования (ключ - код ошибки, значение - описание ошибки)
// определенный код ошибки.
    val m12 = mapOf(123 to "error1", 123456 to "error2", 435 to "error3")
    val r2 = m12.containsKey(435)

//13.Дан неизменяемый словарь, где ключи — это идентификаторы тестовых сценариев в формате "TestID_Version", а
// значения — статусы выполнения этих тестов ("Passed", "Failed", "Skipped"). Отфильтруйте словарь, оставив только
// те сценарии, идентификаторы которых соответствуют определённой версии тестов, то-есть в ключе содержится требуемая
// версия.
    val m13 = mapOf("testID_1" to "passed", "testID_2" to "failed", "testID_13" to "skipped", "tttID_1" to "passed")
    m13.filter { it.key.endsWith("ID_1") }.forEach { println("${it.key} has status ${it.value}") }
    val filteredMap = m13.filter { it.key.endsWith("ID_1") }

//14.У вас есть словарь, где ключи — это названия функциональных модулей приложения, а значения — результаты их
// тестирования. Проверьте, есть ли модули с неудачным тестированием.
    val m14 = mutableMapOf("nam1" to "passed", "nam2" to "failed", "nam3" to "passed")
    val result = m14.containsValue("failed")

//15.Добавьте в изменяемый словарь с настройками тестовой среды настройки из другого словаря.
    val m15 = mutableMapOf("nam1" to "1", "nam2" to "2", "nam3" to "3")
    val new_m15 = mutableMapOf("nam4" to "1", "nam5" to "2", "nam6" to "3")
    m15.putAll(new_m15)

//16.Объедините два неизменяемых словаря с данными о багах.
    val m16 = mapOf("bag1" to "1", "bag2" to "2", "bag3" to "3")
    val newM16 = m16 + mapOf("bag4" to "1", "bag6" to "2", "bag7" to "3")

//17.Очистите изменяемый словарь с временными данными о последнем прогоне автоматизированных тестов.
    m15.clear()

//18.Исключите из отчета по автоматизированному тестированию те случаи, где тесты были пропущены (имеют статус
// “skipped”). Ключи - название теста, значения - статус.
    val m18 = mutableMapOf("test1" to "skipped", "test2" to "failed", "test3" to "passed")
    m18.filterValues { it != "skipped" }.forEach { println("${it.key} has status ${it.value}") }

//19.Создайте копию словаря с конфигурациями тестирования удалив из него несколько конфигураций.
    val m19 = mapOf("code" to "xxx", "style" to "yyy", "browserType" to "Chrome")
    val copy19 = m19 - "code"
    println(copy19)

//20.Создайте отчет о тестировании, преобразовав словарь с результатами тестирования (ключ — идентификатор теста,
// значение — результат) в список строк формата "Test ID: результат".
    val m20 = mutableMapOf("test1" to "skipped", "test2" to "failed", "test3" to "passed")
    val list = m20.map { "Test ${it.key}: ${it.value}" }
    println(list)

//21.Преобразуйте изменяемый словарь с результатами последнего тестирования в неизменяемый для архивации.
    val m21 = m20.toMap()

//22.Преобразуйте словарь, содержащий числовой ID теста и данные о времени выполнения тестов, заменив идентификаторы
// тестов на их строковый аналог (например через toString()).
    val m22 = mutableMapOf(123 to "time1", 123456 to "time2", 435 to "time3")
    val m22New = m22.mapKeys { it.key.toString() }

//23.Для словаря с оценками производительности различных версий приложения (ключи - строковая версия, значения -
// дробное число времени ответа сервера) увеличьте каждую оценку на 10%, чтобы учесть новые условия тестирования.
    val m23 = mutableMapOf("version1" to 3.45, "version2" to 3.46, "version3" to 3.49)
    m23.mapValues { it.value * 1.1 }

//24.Проверьте, пуст ли словарь с ошибками компиляции тестов.
    m22.isEmpty()

//25.Убедитесь, что словарь с результатами нагрузочного тестирования не пуст.
    m22.isNotEmpty()

//26.Проверьте, прошли ли успешно все автоматизированные тесты в словаре с результатами.
     m20.all{it.value =="passed"}

//27.Определите, содержит ли словарь с результатами тестирования хотя бы один тест с ошибкой.
    m20.any{it.value =="failed"}

//28.Отфильтруйте словарь с результатами тестирования сервисов, оставив только те тесты, которые не прошли успешно
// и содержат в названии “optional”.
    m20.filterNot { it.value=="passed" }.filter { it.key.contains("optional") }.forEach{println(it)}

}
